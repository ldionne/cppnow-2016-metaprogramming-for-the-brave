<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Metaprogramming for the brave</title>

        <meta name="author" content="Louis Dionne">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## Metaprogramming for the brave
### Louis Dionne, C++Now 2016

==============================================================================

## No cute intro, this is a serious talk

![Rambo](img/rambo.jpg)

====================

## Outline

- Logical operations
- Algorithms on heterogeneous sequences
- Tuples
- Miscellaneous things to avoid

<!-- To present:
    - compile-time hash table
    - problems with long symbols?
 -->

====================

### Eager logical operations
#### (Roland Bock)

```cpp
template <bool ...> struct bools;

template <typename ...Bools>
struct logical_and
    : std::is_same<
        bools<Bools::value...>,
        bools<(Bools::value, true)...>
    >
{ };
```

====================

### Short circuiting logical operations
#### (Eric Fiselier)

```cpp
template <typename Condition, typename T = void>
struct lazy_enable_if
    : std::enable_if<Condition::value, T>
{ };

std::true_type expand(...);

template <typename ...Bools>
decltype(expand(typename lazy_enable_if<Bools, int>::type{}...))
and_impl(int);

template <typename ...Bools>
std::false_type and_impl(...);

template <typename ...Bools>
struct logical_and
    : decltype(and_impl<Bools...>(int{}))
{ };
```

====================

## Which one is faster?
### No idea, must benchmark

----

### Seriously, _always benchmark_

----

### When the conditions are light to evaluate

<!-- .slide: data-state="haschart" -->
<div class='benchmark-chart'>
{"title":{"text":"Logical and (light predicate)"},"data":[{"key":"dataset.lazy_logical_and-light","values":[{"n":0,"time":0.03312509099487215,"size":4.352},{"n":50,"time":0.033479839912615716,"size":4.352},{"n":100,"time":0.03604643198195845,"size":4.352},{"n":150,"time":0.038891217089258134,"size":4.352},{"n":200,"time":0.03906381002161652,"size":4.352},{"n":250,"time":0.03900368697941303,"size":4.352},{"n":300,"time":0.03910284105222672,"size":4.352},{"n":350,"time":0.044522322015836835,"size":4.352},{"n":400,"time":0.0447621860075742,"size":4.352},{"n":450,"time":0.04388416791334748,"size":4.352},{"n":500,"time":0.04906581295654178,"size":4.352},{"n":550,"time":0.045889021013863385,"size":4.352},{"n":600,"time":0.05128249106928706,"size":4.352},{"n":650,"time":0.052320915972813964,"size":4.352},{"n":700,"time":0.05341404804494232,"size":4.352},{"n":750,"time":0.053003643988631666,"size":4.352},{"n":800,"time":0.05221073504071683,"size":4.352},{"n":850,"time":0.055532186990603805,"size":4.352},{"n":900,"time":0.0578602779423818,"size":4.352},{"n":950,"time":0.05414270900655538,"size":4.352},{"n":1000,"time":0.06071147904731333,"size":4.352},{"n":1050,"time":0.0636887620203197,"size":4.352},{"n":1100,"time":0.06043199705891311,"size":4.352},{"n":1150,"time":0.06077967106830329,"size":4.352},{"n":1200,"time":0.060943412012420595,"size":4.352},{"n":1250,"time":0.0612889250041917,"size":4.352},{"n":1300,"time":0.06144578498788178,"size":4.352},{"n":1350,"time":0.0648001420777291,"size":4.352},{"n":1400,"time":0.06603239697869867,"size":4.352},{"n":1450,"time":0.06995789706707001,"size":4.352},{"n":1500,"time":0.07205789408180863,"size":4.352},{"n":1550,"time":0.06731965392827988,"size":4.352},{"n":1600,"time":0.06807753199245781,"size":4.352},{"n":1650,"time":0.07129844301380217,"size":4.352},{"n":1700,"time":0.07610219495836645,"size":4.352},{"n":1750,"time":0.07655125600285828,"size":4.352},{"n":1800,"time":0.07402275991626084,"size":4.352},{"n":1850,"time":0.0790857239626348,"size":4.352},{"n":1900,"time":0.08115482702851295,"size":4.352},{"n":1950,"time":0.07676989608444273,"size":4.352},{"n":2000,"time":0.08247573208063841,"size":4.352}]},{"key":"dataset.eager_logical_and-light","values":[{"n":0,"time":0.03368991892784834,"size":4.352},{"n":50,"time":0.03555151401087642,"size":4.352},{"n":100,"time":0.03839207405690104,"size":4.352},{"n":150,"time":0.037513275048695505,"size":4.352},{"n":200,"time":0.037893989006988704,"size":4.352},{"n":250,"time":0.03831595100928098,"size":4.352},{"n":300,"time":0.04231709009036422,"size":4.352},{"n":350,"time":0.042535134009085596,"size":4.352},{"n":400,"time":0.0463957660831511,"size":4.352},{"n":450,"time":0.04557946405839175,"size":4.352},{"n":500,"time":0.056865915074013174,"size":4.352},{"n":550,"time":0.047571595991030335,"size":4.352},{"n":600,"time":0.05206065205857158,"size":4.352},{"n":650,"time":0.04810725909192115,"size":4.352},{"n":700,"time":0.05408161098603159,"size":4.352},{"n":750,"time":0.0619772810023278,"size":4.352},{"n":800,"time":0.0651477730134502,"size":4.352},{"n":850,"time":0.06581090297549963,"size":4.352},{"n":900,"time":0.05884701001923531,"size":4.352},{"n":950,"time":0.057176231988705695,"size":4.352},{"n":1000,"time":0.06089306797366589,"size":4.352},{"n":1050,"time":0.05895463505294174,"size":4.352},{"n":1100,"time":0.06435375998262316,"size":4.352},{"n":1150,"time":0.06212516303639859,"size":4.352},{"n":1200,"time":0.06060274795163423,"size":4.352},{"n":1250,"time":0.0662582020740956,"size":4.352},{"n":1300,"time":0.06863750098273158,"size":4.352},{"n":1350,"time":0.0658103609457612,"size":4.352},{"n":1400,"time":0.06921463401522487,"size":4.352},{"n":1450,"time":0.06584449403453618,"size":4.352},{"n":1500,"time":0.07970401702914387,"size":4.352},{"n":1550,"time":0.0932986909756437,"size":4.352},{"n":1600,"time":0.08284110599197447,"size":4.352},{"n":1650,"time":0.0716023159911856,"size":4.352},{"n":1700,"time":0.07236378302332014,"size":4.352},{"n":1750,"time":0.08732690301258117,"size":4.352},{"n":1800,"time":0.07574641902465373,"size":4.352},{"n":1850,"time":0.07803076202981174,"size":4.352},{"n":1900,"time":0.08153761399444193,"size":4.352},{"n":1950,"time":0.08186672697775066,"size":4.352},{"n":2000,"time":0.08782877796329558,"size":4.352}]}]}
</div>

----

### When the conditions are heavy to evaluate

<!-- .slide: data-state="haschart" -->
<div class='benchmark-chart'>
{"title":{"text":"Logical and (heavy predicate)"},"data":[{"key":"dataset.lazy_logical_and-heavy","values":[{"n":0,"time":0.03457747306674719,"size":4.352},{"n":50,"time":0.057800009031780064,"size":4.352},{"n":100,"time":0.08856319810729474,"size":4.352},{"n":150,"time":0.1179371199104935,"size":4.352},{"n":200,"time":0.13878582103643566,"size":4.352},{"n":250,"time":0.1683621860574931,"size":4.352},{"n":300,"time":0.19501060992479324,"size":4.352},{"n":350,"time":0.21798726997803897,"size":4.352},{"n":400,"time":0.24994450306985527,"size":4.352},{"n":450,"time":0.273603969020769,"size":4.352},{"n":500,"time":0.30010824801865965,"size":4.352},{"n":550,"time":0.35356780095025897,"size":4.352},{"n":600,"time":0.380875819013454,"size":4.352},{"n":650,"time":0.4033903949894011,"size":4.352},{"n":700,"time":0.434545919066295,"size":4.352},{"n":750,"time":0.43916780001018196,"size":4.352},{"n":800,"time":0.46883344498928636,"size":4.352},{"n":850,"time":0.5100441209506243,"size":4.352},{"n":900,"time":0.5508588580414653,"size":4.352},{"n":950,"time":0.575399336987175,"size":4.352},{"n":1000,"time":0.5945708829676732,"size":4.352},{"n":1050,"time":0.6580227309605107,"size":4.352},{"n":1100,"time":0.6802825049962848,"size":4.352},{"n":1150,"time":0.6826359409606084,"size":4.352},{"n":1200,"time":0.7301543770590797,"size":4.352},{"n":1250,"time":0.7289095720043406,"size":4.352},{"n":1300,"time":0.7572243800386786,"size":4.352},{"n":1350,"time":0.7964663829188794,"size":4.352},{"n":1400,"time":0.812457061954774,"size":4.352},{"n":1450,"time":0.8407797589898109,"size":4.352},{"n":1500,"time":0.8872638319153339,"size":4.352},{"n":1550,"time":0.8895956169581041,"size":4.352},{"n":1600,"time":0.9267066849861294,"size":4.352},{"n":1650,"time":0.974082748987712,"size":4.352},{"n":1700,"time":0.9965054969070479,"size":4.352},{"n":1750,"time":0.9948154169833288,"size":4.352},{"n":1800,"time":1.0252971230074763,"size":4.352},{"n":1850,"time":1.059508775942959,"size":4.352},{"n":1900,"time":1.077089708065614,"size":4.352},{"n":1950,"time":1.1432388469111174,"size":4.352},{"n":2000,"time":1.1376166170230135,"size":4.352}]},{"key":"dataset.eager_logical_and-heavy","values":[{"n":0,"time":0.03668104798998684,"size":4.352},{"n":50,"time":0.08055901399347931,"size":4.352},{"n":100,"time":0.13982920197304338,"size":4.352},{"n":150,"time":0.1978315080050379,"size":4.352},{"n":200,"time":0.23189487005583942,"size":4.352},{"n":250,"time":0.2940798909403384,"size":4.352},{"n":300,"time":0.3496384380850941,"size":4.352},{"n":350,"time":0.4100802899338305,"size":4.352},{"n":400,"time":0.4618455220479518,"size":4.352},{"n":450,"time":0.5057177220005542,"size":4.352},{"n":500,"time":0.5556255569681525,"size":4.352},{"n":550,"time":0.6314529459923506,"size":4.352},{"n":600,"time":0.6752461560536176,"size":4.352},{"n":650,"time":0.7277212109183893,"size":4.352},{"n":700,"time":0.7797713779145852,"size":4.352},{"n":750,"time":0.8311718730255961,"size":4.352},{"n":800,"time":0.9040338929044083,"size":4.352},{"n":850,"time":0.9602879818994552,"size":4.352},{"n":900,"time":1.005287489038892,"size":4.352},{"n":950,"time":1.035785244894214,"size":4.352},{"n":1000,"time":1.128794931108132,"size":4.352},{"n":1050,"time":1.1698589948937297,"size":4.352},{"n":1100,"time":1.2522548889974132,"size":4.352},{"n":1150,"time":1.2796355210011825,"size":4.352},{"n":1200,"time":1.3467423389665782,"size":4.352},{"n":1250,"time":1.38959320995491,"size":4.352},{"n":1300,"time":1.4345248460303992,"size":4.352},{"n":1350,"time":1.5017189719947055,"size":4.352},{"n":1400,"time":1.5360283559421077,"size":4.352},{"n":1450,"time":1.5757863090839237,"size":4.352},{"n":1500,"time":1.6500117970863357,"size":4.352},{"n":1550,"time":1.671914879931137,"size":4.352},{"n":1600,"time":1.7348869260167703,"size":4.352},{"n":1650,"time":2.1110183600103483,"size":4.352},{"n":1700,"time":1.9976689879549667,"size":4.352},{"n":1750,"time":2.0250211249804124,"size":4.352},{"n":1800,"time":2.038336990051903,"size":4.352},{"n":1850,"time":2.02566038898658,"size":4.352},{"n":1900,"time":2.0987599489744753,"size":4.352},{"n":1950,"time":2.121139583992772,"size":4.352},{"n":2000,"time":2.1952559739584103,"size":4.352}]}]}
</div>

====================

### Algorithms on heterogeneous sequences

====================

### `transform`

```cpp
template <typename ...T, typename F, std::size_t ...i>
auto transform_impl(std::tuple<T...> const& tuple, F const& f,
                    std::index_sequence<i...>)
{
    return std::make_tuple(f(std::get<i>(tuple))...);
}

template <typename ...T, typename F>
auto transform(std::tuple<T...> const& tuple, F const& f) {
    return transform_impl(tuple, f,
                std::make_index_sequence<sizeof...(T)>{});
}
```

====================

### `for_each`

```cpp
template <typename ...T, typename F, std::size_t ...i>
void for_each_impl(std::tuple<T...> const& tuple, F const& f,
                   std::index_sequence<i...>)
{
    int expand[] = {0, (f(std::get<i>(tuple)), void(), 0)...};
    (void)expand;
}

template <typename ...T, typename F>
void for_each(std::tuple<T...> const& tuple, F const& f) {
    for_each_impl(tuple, f, std::make_index_sequence<sizeof...(T)>{});
}
```

====================

## Easy so far

====================

### `tuple_cat`

```cpp
constexpr boost::hana::tuple<> tuple_cat() {
    return boost::hana::tuple<>();
}

template <typename Types, typename Is, typename Js>
struct tuple_cat_impl;

template <typename ...T, size_t ...I, size_t ...J>
struct tuple_cat_impl<boost::hana::tuple<T...>,
                      std::index_sequence<I...>,
                      std::index_sequence<J...>>
{
    template <typename Tuple0>
    constexpr auto operator()(boost::hana::tuple<T...> t, Tuple0&& t0) {
        return ::forward_as_tuple(std::forward<T>(boost::hana::at_c<I>(t))...,
                                  boost::hana::at_c<J>(std::forward<Tuple0>(t0))...);
    }

    template <typename Tuple0, typename Tuple1, typename ...Tuples>
    constexpr auto operator()(boost::hana::tuple<T...> t, Tuple0&& t0, Tuple1&& t1, Tuples&& ...tpls) {
        using T0 = typename std::remove_reference<Tuple0>::type;
        using T1 = typename std::remove_reference<Tuple1>::type;
        return tuple_cat_impl<
            boost::hana::tuple<
                T...,
                typename apply_cv<Tuple0, typename tuple_element<J, T0>::type>::type&&...
            >,
            std::make_index_sequence<sizeof ...(T) + tuple_size<T0>::value>,
            std::make_index_sequence<tuple_size<T1>::value>
        >{}(
            ::forward_as_tuple(
                std::forward<T>(boost::hana::at_c<I>(t))...,
                boost::hana::at_c<J>(std::forward<Tuple0>(t0))...
            ),
            std::forward<Tuple1>(t1),
            std::forward<Tuples>(tpls)...
        );
    }
};

template <typename Tuple0, typename ...Tuples>
constexpr auto tuple_cat(Tuple0&& t0, Tuples&& ...tpls) {
    using T0 = typename std::remove_reference<Tuple0>::type;
    return tuple_cat_impl<
        boost::hana::tuple<>,
        std::index_sequence<>,
        std::make_index_sequence<tuple_size<T0>::value>
    >{}(
        boost::hana::tuple<>{},
        std::forward<Tuple0>(t0),
        std::forward<Tuples>(tpls)...
    );
}
```

----

### This is wrong!

----

### `tuple_cat`, take two

```cpp
template <std::size_t ...Lengths>
struct flatten_indices {
    static constexpr std::size_t lengths[] = {Lengths..., 0};
    static constexpr auto flat_length =
        mystd::accumulate(lengths, lengths + sizeof...(Lengths), 0);

    template <bool Inner>
    static constexpr auto compute() {
        mystd::array<std::size_t, flat_length> indices{};
        for (std::size_t index = 0, i = 0; i < sizeof...(Lengths); ++i)
            for (std::size_t j = 0; j < lengths[i]; ++j, ++index)
                indices[index] = (Inner ? i : j);
        return indices;
    }

    static constexpr auto inner = compute<true>();
    static constexpr auto outer = compute<false>();

    template <typename Tuples, std::size_t ...i>
    static constexpr auto apply(Tuples tuples, std::index_sequence<i...>) {
        return boost::hana::make_tuple(
            boost::hana::at_c<outer[i]>(boost::hana::at_c<inner[i]>(tuples))...
        );
    }
};

template <typename ...Tuples>
constexpr auto tuple_cat(Tuples&& ...tuples) {
    using Indices = flatten_indices<
        tuple_size<typename std::remove_reference<Tuples>::type>::value...
    >;
    return Indices::apply(
        ::forward_as_tuple(std::forward<Tuples>(tuples)...),
        std::make_index_sequence<Indices::flat_length>{}
    );
}
```

----

<!-- .slide: data-state="haschart" -->
<div class='benchmark-chart'>
{"title":{"text":"tuple_cat"},"data":[{"key":"dataset.my_tuple_cat","values":[{"n":0,"time":0.10495949001051486,"size":16.848},{"n":10,"time":0.1721977210836485,"size":50.824},{"n":20,"time":0.25970316492021084,"size":93.632},{"n":30,"time":0.3155090189538896,"size":133.088},{"n":40,"time":0.40616536303423345,"size":177.232},{"n":50,"time":0.5061050989897922,"size":217.888},{"n":60,"time":0.5897400249959901,"size":267.328},{"n":70,"time":0.6893566360231489,"size":309.184},{"n":80,"time":0.8009700709953904,"size":355.728},{"n":90,"time":0.9364177630050108,"size":398.792},{"n":100,"time":1.0786939030513167,"size":446.544}]},{"key":"dataset.std_tuple_cat","values":[{"n":0,"time":0.11974298395216465,"size":15.944},{"n":10,"time":0.5000602030195296,"size":213.208},{"n":20,"time":1.6388250349555165,"size":866.384},{"n":30,"time":3.8604790170211345,"size":2122.304},{"n":40,"time":7.482939457055181,"size":4131.488},{"n":50,"time":14.919495346955955,"size":7039.848},{"n":60,"time":32.500950405956246,"size":10997.392},{"n":70,"time":29.762316133012064,"size":16162.368},{"n":80,"time":35.014632397913374,"size":22680.624},{"n":90,"time":88.30343898397405,"size":30698.04},{"n":100,"time":101.40765085897874,"size":40364.648}]}]}
</div>

====================

### The idea
Perform the computation on indices, and then involve the original sequence

====================

### Another one

====================

### `filter` (naive)

```cpp
#error TODO

template <typename ...T, typename Predicate>
constexpr auto filter(std::tuple<T...> const& xs, Predicate const& pred) {
    return filter_impl(xs, pred, std::make_index_sequence<sizeof...(T)>{});
}
```

----

### `filter` (good)

```cpp

```

----

<!-- .slide: data-state="haschart" -->
<div class='benchmark-chart'>
<!-- TODO: do this benchmark -->
</div>

====================

### Let's now dive into tuples

----

### Classic multiple inheritance



----

### Aligned storage (experimental)




Note:
Alisdair will present something similar in his presentation, so I won't go
into the details here.

====================

### Benefits of aligned storage

----

### Some algorithms are killer



----

### Can optimize empty types easily

<!-- TODO -->

----

### Easy to optimize for the compiler

<!-- TODO: Show generated assembly of both techniques -->

----

### Possibility of pre-allocating storage

<!-- TODO: Experiment with pre-allocating algorithms -->

====================

### Downsides of aligned storage

----

### Can't be constexpr (in-place `new`)

<!-- TODO: Show small example -->

----

### Slower than multiple inheritance

<!-- TODO: Show benchmark -->


Note:
This is surprising, as we would expect pure constexpr to be faster than
multiple inheritance. It appears that constexpr evaluation is far from free.
Again, always benchmark!

====================

### Miscellaneous things to avoid

====================

### Long symbol names

<!-- TODO: explain the issue and show how it can be eliminated using anonymous namespaces or LTO -->

====================

### Excessive use of overloading

<!-- TODO: Explain that overloading is slow, and show benchmark of how it scales w.r.t. number of arguments -->

====================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne
</span>


                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'slide',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true }
                    // , { src: 'plugin/remotes/remotes.js', async: true }
                ]
            });
        </script>

        <!-- Additional javascript for drawing charts. -->
        <script type="text/javascript" src="js/jquery.min.js"></script>
        <script type="text/javascript" src="js/highcharts.min.js"></script>
        <script type="text/javascript" src="js/highcharts-data.min.js"></script>
        <script type="text/javascript" src="js/highcharts-exporting.min.js"></script>
        <script type="text/javascript" src="js/chart.js"></script>
        <script type="text/javascript">
          window.onload = function() {
            $(".benchmark-chart").each(function(index, div) {
                var options = JSON.parse(div.innerHTML);
                var data = options.data; delete options.data;
                options.series = data.map(function(dataset) {
                    return {
                        name: dataset.key,
                        data: dataset.values.map(function(datum) {
                            return [datum.n, datum.time];
                        })
                    };
                });

                Hana.initChart($(div), options);
            });
          };
        </script>

        <!--
          Some slides contain charts in them. Sometimes, the charts will not
          be properly centered in the slide. To fix this, slides with the
          `data-state="haschart"` attribute trigger a reflowing of all the
          charts inside their div, which is overkill but fixes the problem.
        -->
        <script type="text/javascript">
            Reveal.addEventListener('haschart', function() {
                Highcharts.charts.forEach(function(chart) {
                    chart.reflow();
                });
            }, false);
        </script>
    </body>
</html>

